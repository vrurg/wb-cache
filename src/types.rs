use crate::{entry::Entry, traits::DataController};
use std::{fmt::Debug, sync::Arc};

pub enum CompResult<DC>
where
    DC: DataController,
{
    Inserted(Entry<DC>),
    ReplacedWith(Entry<DC>),
    Removed(Entry<DC>),
    Unchanged(Entry<DC>),
    StillNone(Arc<DC::Key>),
}

impl<DC> Debug for CompResult<DC>
where
    DC: DataController,
{
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Inserted(e) => fmt.debug_tuple("CompResult::Inserted").field(e).finish(),
            Self::Removed(e) => fmt.debug_tuple("CompResult::Removed").field(e).finish(),
            Self::ReplacedWith(e) => fmt.debug_tuple("CompResult::ReplacedWith").field(e).finish(),
            Self::Unchanged(e) => fmt.debug_tuple("CompResult::Unchanged").field(e).finish(),
            Self::StillNone(k) => fmt.debug_tuple("CompResult::StillNone").field(k).finish(),
        }
    }
}

/// What the cache controller should do with the initial value that was submitted for data controller processing.
#[derive(Debug, Clone, Copy)]
pub enum DataControllerOp {
    /// Do nothing, only put the returned update record into the update pool.
    Nop,
    /// Insert the value into the cache. This is possible for "immutable" records, i.e., those for which it can be
    /// guaranteed that they won't be changed by the backend. For example, if the primary key field is pre-generated by
    /// the client application, then inserting the record into the database won't change it. If the same guarantee can
    /// be made for all other fields as well, it means that injecting the value into the cache immediately would have
    /// the same effect as inserting it into the database and then reading it back.
    ///
    /// Contrary, if there is an auto-increment field in the record, then sending it to the backend and reading it back
    /// is mandatory to achieve a consistent final state.
    Insert,
    /// Revoke the value from the cache. Useful for cases when the data controller knows that the value must undergo a
    /// flushing operation either to be deleted from the backend or to be updated.
    Revoke,
    /// An extreme case of the `Revoke` operation. The value is not only revoked from the cache, but the corresponding entry
    /// is also removed from the update pool. This would be an ideal case of an "immutable" record which is inserted and deleted
    /// sufficiently fast to not require being written back to the backend.
    Drop,
}

pub struct DataControllerResponse<DC>
where
    DC: DataController,
{
    pub op: DataControllerOp,
    pub update: Option<DC::CacheUpdate>,
}

impl<DC> Debug for DataControllerResponse<DC>
where
    DC: DataController,
{
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("DataControllerResponse")
            .field("op", &self.op)
            .field("update", &self.update)
            .finish()
    }
}
